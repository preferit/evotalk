Go: Project structure; design for change, avoid a deadend

From the simplest "func main" to a large service. What choices to
consider when your project grows and how to keep it on track for
future changes.

We begin with hello world and then evolve that example into any
direction. Along the way depending on the choices we make the design
of our project will change. I'll refer to directory layout, not as
structure but as design.

Let's kick off our project; which we at this point do not know what it
will do. We'll name it "rebel" and use the repository domain
"github.com/preferit/rebel".

                TODO $ cd ex/01; tree
                TODO $ cat ex/01/main.go

We choose to create a command, ie. package main. The implications for
our ability to evolve

1. You Cannot share any logic within it with others (including
yourself), Go disallows the import of main packages

2. API documentation is hidden when using e.g. go doc, as a result of
(1)

                TODO screenshot of godoc ex/01

This is a starting point; you have no intention to share any logic
only the command as such. You are happy and code along the nice
feature of randomizing rebelious statements.

                TODO $ cat ex/02/main.go

At this point your coworkers Max and Lisa see the work and you end up
in a discussion;

- Max:  Would be nice to see that phrase when I login as the message of the day
- you:  Easy peasy, just go install ... and run it.
- Lisa: Can we include it on the intranet?
- you:  Hmm.. (you pause and start thinking)
- you:  Not really; you could use the binary, but it would be slow with all the
        traffic we have

Here you are faced with a decision on how to share the logic of
generating a random rebelious statement.

1. Redesign the logic as an importable package or
2. Write a small service with an API.
3. Share the data only and let them figure it out

The first and second option will both require some effort. As the
consumers are both internal the first seems more fitting and much
easier to do. The third option, though viable, does not help this
presentation :-).

How do you convert the current state, a command, into an importable
package while also keeping the command. First attempt; keep command in
root and create a package with logic to generate the phrases.

               TODO $ tree ex/03
	       TODO $ cat ex/03/phrase/*.go

With a little refactoring everyone can benefit from your rebel
statement generator. What are the implications of our current design?
We now have multiple stakeholders depending on it and going forward
they might get affected. Our goal is to be able to make changes as
freely as possible without affecting the stakeholders. Before we
release these changes can we improve the design?

               TODO $ tree ex/04
	       TODO $ cat ex/04/phrase/*.go


