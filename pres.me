.ll 10i \" landscape width, used together with groff -P-pa4 -P-l
.he ''Design for change, avoid a deadend''
.fo 'v0.1.0'%' \" footer 'left'middle'right'
.tp \" title page
.sp 2i
.(l C
.ps 40
.b "Go: Design for change"
.sp 3
.ps 20
.b "avoid a deadend"
.sp
.ps 12
by
.sp
.ft U-TR
Gregory Vinčić \" requires -Dutf-8
.)l
.
.ap
.bp \" -----------------------------------------------------

From the simplest "func main" to a large service. What choices to
consider when your project grows and how to keep it on track for
future changes.

We begin with hello world and then evolve that example into any
direction. Along the way depending on the choices we make the design
of our project will change. I'll refer to directory layout, not as
structure but as design.

Let's kick off our project; which we at this point do not know what it
will do. We'll name it "rebel" and use the repository domain
"github.com/preferit/rebel".

                TODO $ cd ex/01; tree
                TODO $ cat ex/01/main.go

We choose to create a command, ie. package main. The implications for
our ability to evolve

1. You Cannot share any logic within it with others (including
yourself), Go disallows the import of main packages

2. API documentation is hidden when using e.g. go doc, as a result of
(1)

                TODO screenshot of godoc ex/01

This is a starting point; you have no intention to share any logic
only the command as such. You are happy and code along the nice
feature of randomizing rebelious statements.

                TODO $ cat ex/02/main.go

At this point your coworkers Max and Lisa see the work and you end up
in a discussion;

- Max:  Would be nice to see that phrase when I login as the message of the day
- you:  Easy peasy, just go install ... and run it.
- Lisa: Can we include it on the intranet?
- you:  Hmm.. (you pause and start thinking)
- you:  Not really; you could use the binary, but it would be slow with all the
        traffic we have

Here you are faced with a decision on how to share the logic of
generating a random rebelious statement.

1. Redesign the logic as an importable package or
2. Write a small service with an API.
3. Share the data only and let them figure it out

The first and second option will both require some effort. As the
consumers are both internal the first seems more fitting and much
easier to do. The third option, though viable, does not help this
presentation :-).

How do you convert the current state, a command, into an importable
package while also keeping the command. First attempt; keep command in
root and create a package with logic to generate the phrases.

               TODO $ tree ex/03
	       TODO $ cat ex/03/phrase/*.go

With a little refactoring everyone can benefit from your rebel
statement generator. What are the implications of our current design?
We now have multiple stakeholders depending on it and going forward
they might get affected. Our goal is to be able to make changes as
freely as possible without affecting the stakeholders. Before we
release these changes can we improve the design?

               TODO $ tree ex/04
	       TODO $ cat ex/04/phrase/*.go

Your use case and Maxs are somewhat aligned as you both use the rebel
logic of shouting through the rebel command. You quickly notice that
the same phrase appears over and over and add a the feature of keeping
last shouted phrase in a temporary file to minimize the repetition
when you run your commands.

	       TODO $ cat ex/05/main.go

Some time passes and Lisas swings by your office asking if you could
implement something that doesn't repeat the same phrase every day?
But you just did, how do you now share it with Lisa?  At this point
you'll realize that the initial redesign with the added phrase
package, may need to changed and your own code updated aswell. This is
one of those deadends where you have to turn around and find another
path. We can explore ways to use the current design, e.g. put some
caching mechanism into the phrase package, but that seems out of
place.  Also the caching for the command invocation locally on your
computer may differ from what is available on the intranet site, you
don't know at this point.  If we backtrack to the time where Max and
Lisa came onboard, could we have taken a different route that would
avoid this scenario?

Let's go through our reasoning and see if we can find the culprit
before trying to solve it. Lisa and Max where not very specific about
their needs just that they wanted to show a random phrase in different
ways. We choose to extract the phrase generating logic for Lisa to use
and told Max to use the command. What Lisa wants now is the logic that
is found in the command, but her current dependency is elsewhere.

Looking at the code more closely we placed func Shout inside the
phrase package, why? phrases don't shout, rebels do. So if we want to
keep func Shout in the package rebel And we want to share it with
Lisa, how do we solve that?

Move command, keep domain logic.

            TODO $ tree ex/06/

This design, is as effortless as the first attempt at the decision
point, but it makes it easier to evolve the rebel logic. It also
forces you to design rebel features in such a way that they may be
used by Lisa as well as Max.

The project will grow and at some Point Lisa will come by and says
they are switching languages for the intranet implementation but they
really want to have access to the logic of generating rebelious
statements, could you write a service that exposes it?


